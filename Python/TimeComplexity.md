# 시간 복잡도 & 빅오 표기법

## 1. 알고리즘의 시간 복잡도

> 좋은 알고리즘이란 무엇일까?
>
> == 효율성이 좋은 알고리즘?
>
> == 성능이 좋은 알고리즘?
>
> == Input을 넣은 후 Output이 나오는 **시간**이 짧은 알고리즘!

<br />

- 알고리즘의 소요 시간 측정하기 -1
  - 개개인의 컴퓨팅 환경에 따라 같은 알고리즘이라도 측정 시간이 다르다.
  - 환경에 영향을 받지 않는 객관적인 기준이 필요하다.
- 알고리즘의 소요 시간 측정하기 -2
  - 객관적인 측정을 위해 알고리즘 내부에서 기본 연산이 몇 번 일어나는지 살펴본다.
    - 기본 연산 : 단위 시간 1이 소요되는 연산
      - ex) 할당, 산술, 비교, 반환 ...
    - 기본 연산의 총 횟수 == 알고리즘의 소요 시간

<br />

## 2. 시간 복잡도 (Time Complexity)

> 계산 복잡도 이론에서 시간 복잡도는 문제를 해결하는데 걸리는 시간과 입력의 함수 관계를 가리킨다.

- 단순하게 알고리즘의 수행 시간을 의미
  - 시간 복잡도가 높다 -> 느린 알고리즘
  - 시간 복잡도가 낮다 -> 빠른 알고리즘
- 성능을 측정할 때는 입력을 통일시킨다.
  - 가장 기본 연산이 많이 일어나는 최악의 입력 n개가 들어온다고 가정

- 시간 복잡도에 따라 알고리즘의 성능을 비교해보자
  - 1. `6n+4`, `3n+2`. `3n^2+6n+1` => 세 번째 사람 제곱으로 증가함

<br />

## 3. 빅오(Big-O) 표기법

> 입력 n이 **무한대**로 커진다고 가정하고 시간 복잡도를 간단하게 표시하는 것

- **최고차항**만 남기고 계수와 상수 제거
- 매 입력에 따라 정확한 수식을 구하는 것은 불필요하다.
- 정확한 수치보다는 **증가율**에 초점을 맞춘다.



- `O(2^n)` > `O(n^2)` > `O(n log n)` >`O(n)` > `O(log n)` > `O(1)`

![TimeComplexity](TimeComplexity.assets/TimeComplexity.PNG)

<br /><br />

- `빅오(Big-O)` 표기법

    | 표기     | 설명                                     | 예시                                                |
    | -------- | ---------------------------------------- | --------------------------------------------------- |
    | O(1)     | 단순 산술 계산(덧셈, 뺄셈, 곱셈, 나눗셈) | a + b, 100 * 200                                    |
    | O(logN)  | 크기 N인 리스트를 반절씩 순회/탐색       | 이진탐색(Binary Search), 분할정복(Divide & Conquer) |
    | O(N)     | 크기 N인 리스트를 순회                   | 리스트 순회, 1중 for문                              |
    | O(NlogN) | 크기 N인 리스트를 반절씩 탐색 * 순회     | 높은 성능의 정렬(Merge/Quick/Heap Sort)             |
    | O(N^2)   | 크기 M, N인 2중 리스트를 순회            | 2중 리스트 순회, 2중 for문                          |
    | O(N^3)   | 3중 리스트를 순회                        | 3중 리스트 순회, 3중 for문                          |
    | O(2^N)   | 크기 N 집합의 부분 집합                  | 크기가 N인 집합의 부분 집합                         |
    | O(N!)    | 크기 N 리스트의 순열                     | 크기가 N인 수열                                     |

<br />

- 같은 Output을 만드는 알고리즘 이라도 시간 복잡도에 따라 성능이 달라질 수 있고 시험에서 **정답 여부**가 갈리는 포인트가 된다는 것이다.
