# 1. 배열 VS 연결 리스트

## 1) 배열 (Array)

> 여러 데이터들이 연속된 메모리 공간에 저장되어 있는 자료구조

- 인덱스(Index)를 통해 데이터에 빠르게 접근
- 배열의 길이는 변경 불가능 -> 길이를 변경하고 싶다면 새로 생성
- 데이터 타입은 고정

<br />

## 2) 연결 리스트 (Linked List)

> 데이터가 담긴 여러 노드들이 순차적으로 연결된 형태의 자료구조

- 맨 처음 노드부터 순차적으로 탐색
- 연결 리스트의 길이 자유롭게 변경 가능 -> 삽입, 삭제가 편리
- 다양한 데이터 타입 저장
- 데이터가 메모리에 연속적으로 저장되지 않음

<br />

# 파이썬의 리스트

> 배열의 **인덱스 접근** + 연결 리스트의 **가변 길이**
>
> 다양한 데이터 타입 저장 가능

<br />

## 파이썬 리스트의 메서드

| 메서드     | 정의                                                         | 시간 복잡도                           |
| ---------- | ------------------------------------------------------------ | ------------------------------------- |
| .append()  | 리스트 맨 끝에 새로운 원소 **삽입**                          | O(1)                                  |
| .pop()     | 특정 인덱스에 있는 원소를 **삭제 및 반환**                   | .pop(): O(1)<br/>.pop(`<요소>`): O(n) |
| .count()   | 리스트에서 해당 원소의 **개수**를 반환                       | O(n)                                  |
| .index()   | 리스트에서 처음으로 원소가 등장하는 **인덱스** 반환          | O(n)                                  |
| .sort()    | 리스트를 오름차순으로 **정렬**<br/ >**reverse=True** 옵션을 통해 내림차순으로 정렬 가능 | O(n log n)                            |
| .reverse() | 리스트의 원소들의 순서를 거꾸로 **뒤집기**                   | O(n)                                  |

<br />

## 파이썬 리스트 관련 내장 함수

| 내장 함수            | 정의                                                         | 시간 복잡도 |
| -------------------- | ------------------------------------------------------------ | ----------- |
| len(*iterable*)      | 리스트의 **길이**(원소의 개수)를 반환                        | O(1)        |
| sum(*iterable*)      | 리스트의 모든 원소의 **합**을 반환                           | O(n)        |
| max(*iterable*)      | 리스트의 원소 중 **최댓값**을 반환                           | O(n)        |
| min(*iterable*)      | 리스트의 원소 중 **최솟값**을 반환                           | O(n)        |
| sorted(*iterable*)   | 오름차순으로 **정렬**된 새로운 리스트 반환<br/ >원본 리스트 변화 없음 | O(n log n)  |
| reversed(*iterable*) | 리스트의 순서를 **거꾸로 뒤집은** 새로운 객체 반환<br />원본 리스트 변화 없음 | O(n)        |

