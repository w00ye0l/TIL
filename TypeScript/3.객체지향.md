# 객체 지향 프로그래밍

## 절차 지향

절차 지향 모델링은 프로그램을 **기능중심**으로 바라보는 방식으로 **"무엇을 어떤 절차로 할 것인가?"**가 핵심이 된다. 즉, 어떤 기능을 어떤 순서로 처리하는가에 초점을 맞춘다.



## 객체 지향

객체 지향 모델링은 기능이 아닌 **객체가 중심**이 되며 **"누가 어떤 일을 할 것인가?"**가 핵심이 된다. 즉, 객체를 도출하고 각각의 역할을 정의해 나가는 것에 초점을 맞춘다.



## class

```ts
class Player {
    constructor(
        private firstName: string,
        private lastName: string,
        public nickName: string
    ) {}
}

const nico = new Player("nico", "las", "니꼬");

nico.firstName; // 에러
nico.nickName;
```

Player 클래스를 만들고 property를 작성

자바스크립트에서는 constructor 함수를 만들고 그 안에 this.firstName = firstName이나 this.lastName = lastName과 같은 식으로 작성해야 함

하지만 타입스크립트는 파라미터들만 써준다면 알아서 constructor 함수를 만들어줌

private과 public으로 property를 만들 수 있음. 이 키워드들은 자바스크립트로 컴파일 되면서 사라짐



nico.firstName을 시도하면 타입스크립트가 private이기 때문에 코드 실행을 막아줌

하지만 자바스크립트는 문제 없이 작동함

public 속성은 가능



## abstract class(추상 클래스)

> 오직 다른 클래스가 상속받을 수 있는 클래스
>
> 자바스크립트에서는 추상 클래스 개념이 없고 컴파일 시 그냥 클래스로 변함



### 추상 클래스를 사용하는 이유

> 표준화된 property와 메소드를 갖도록 해주는 청사진을 만들기 위해 사용



```ts
abstract class User {
    constructor(
        private firstName: string,
        private lastName: string,
        public nickName: string
    ) {}
}

class Player extends User {
    
}

const nico = new User("nico", "las", "니꼬"); // 에러
```

추상 클래스 User를 만들고 Player에 있던 constructor 함수를 User에 넣고 Player가 User를 상속받음

추상 클래스로 직접 새로운 인스턴스를 만들 수는 없음



```ts
abstract class User {
    constructor(
        private firstName: string,
        private lastName: string,
        public nickName: string
    ) {}
    public getFullName() {
        return `${this.firstName} ${this.lastName}`
    }
}

class Player extends User {
    
}

const nico = new Player("nico", "las", "니꼬");

nico.getFullName(); // 메소드가 private이 아닐 경우 정상 작동
nico.getFullName(); // 메소드가 private일 경우 에러
```

firstName과 lastName을 합치는 getFullName이라는 메소드를 만듦

Player는 User로부터 상속받았으므로 Player에서도 getFullName 메소드 사용 가능



```ts
abstract class User {
    constructor(
        private firstName: string,
        private lastName: string,
        private nickName: string
    ) {}
    abstract getNickName(): void
    getFullName() {
        return `${this.firstName} ${this.lastName}`
    }
}

class Player extends User {
    
}

const nico = new Player("nico", "las", "니꼬");

nico.getFullName();
```

추상 클래스 안에서는 추상 메소드를 만들 수 있음

메소드를 구현하면 안되고 call signature만을 작성해야 함



getNickName이라는 추상 메소드를 만들고 리턴 값이 void라고 알려줌

괄호 안에 argument를 작성하는 것도 가능함 (argument: type)



추상 메소드는 추상 클래스를 상속받는 모든 것들이 구현을 해야 하는 메소드를 의미

Player가 User를 상속받는다면 User 안에 있는 추상 메소드를 Player에서 구현해야 함

```ts
class Player extends User {
    getNickName() {
        console.log(this.nickName);
    }
}
```

하지만 이는 에러가 발생하는 코드

Player가 User를 상속받았지만 nickName은 private이기 때문에 접근할 수 없음



### private

> private으로 명시된 요소들은 클래스 밖에서 접근할 수 없고, 다른 자식 클래스에서도 접근할 수 없음
>
> 개인적인 것을 말하며, 해당 클래스 내에서만 접근 가능



### public

> 모든 클래스에서 접근 가능



### protected

> 자식 클래스에서도 사용 가능한 속성으로 만드는 방식
>
> 외부에서는 여전히 접근 불가능

```ts
abstract class User {
    constructor(
        protected firstName: string,
        protected lastName: string,
        protected nickName: string
    ) {}
    abstract getNickName(): void
    getFullName() {
        return `${this.firstName} ${this.lastName}`
    }
}

class Player extends User {
    getNickName() {
        console.log(this.nickName);
    }
}
```

추상 클래스의 속성들을 protected로 바꿔주면 자식 클래스인 Player에서도 nickName을 사용할 수 있음



> 추상 클래스, 추상 메소드, protected, public, private은 타입스크립트에서만 사용 가능