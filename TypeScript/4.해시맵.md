# 해시맵

- 해싱 알고리즘을 사용하는 완벽한 해시맵
- 단어 사전



```ts
type Words = {
    [key: string]: string
}

class Dict {
    private words: Words
    constructor() {
        this.words = {}
    }
    add(word: Word) {
        if (this.words[word.term] === undefined) {
            this.words[word.term] = word.def;
        }
    }
    def(term: string) {
        return this.words[term];
    }
}

class Word {
    constructor(
    	public term: string,
        public def: string
    ) { }
}

const kimchi = new Word("kimchi", "한국의 음식");

const dict = new Dict()

dict.add(kimchi);
dict.def("kimchi");
```

Words 타입이 string만을 property로 가지는 오브젝트라는 걸 말해준 것

제한된 양의 property 혹은 key를 가지는 타입을 정의해주는 방법



Dict 클래스에서 words를 initializer 없이 선언하고 constructor에서 수동으로 초기화시킴

constructor에 인자로 넣어 constructor가 지정해주길 바라는 것이 아니기 때문

단어를 추가하는 메소드 add를 만들고 인자의 타입이 **Word 클래스의 인스턴스**라고 알려줌



Word 클래스에서는 term과 def를 인자로 받도록 생성





## Upgrade

```ts
type Words = {
    [key: string]: (string | string[])
}

class Dict {
    private words: Words
    constructor() {
        this.words = {}
    }
    // 사전에 단어 추가
    add(word: Word) {
        if (this.words[word.term] === undefined) {
            this.words[word.term] = word.def;
        }
    }
    // 사전에서 단어 검색
    def(term: string) {
        return this.words[term];
    }
    // 사전에서 단어 삭제
    rmv(term: string) {
        delete this.words[term];
    }
    // 사전 단어 업데이트
    update(oldTerm: string, newTerm: string) {
        if (this.words.hasOwnProperty(oldTerm)) {
            this.words[newTerm] = this.words[oldTerm];
            delete this.words[oldTerm];
        }
    }
    // 사전에 저장된 단어 개수
    size() {
        return Object.keys(this.words).length;
    }
    // 사전의 모든 단어와 정의 출력
    all() {
        for (let [key, value] of Object.entries(this.words)) {
            console.log(`${key}: ${value}`);
        }
    }
}

class Word {
    constructor(
        public term: string,
        public def: (string | string[])
    ) { }
    // 단어 출력
    toString() {
        console.log(`${this.term}: [뜻]${this.def}`);
    }
    // 단어 정의 추가
    addDef(newDef: string) {
        if (typeof this.def === "string") {
            this.def = [this.def, newDef];
        } else {
            this.def = [...this.def, newDef];
        }
    }
    // 단어 정의 업데이트
    updateDef(oldDef: string, newDef: string) {
        if (typeof this.def === "string") {
            if (oldDef === this.def) this.def = newDef
        } else {
            this.def.filter(val => val !== oldDef);
            this.def.push(newDef);
        }
    }
}

const kimchi = new Word("kimchi", "한국의 음식");
const tang = new Word("연근 갈비탕", "중국의 음식");
const sushi = new Word("스시", "일본의 음식");

kimchi.addDef("고춧가루로 배추를 버무려 숙성 및 발효시킨 음식")
kimchi.toString(); // kimchi: 한국의 음식,고춧가루로 배추를 버무려 숙성 및 발효시킨 음식
tang.toString() // 연근 갈비탕: 중국의 음식
sushi.updateDef("일본의 음식", "밥을 뭉쳐놓고 그 위에 재료를 얹어낸 음식");
sushi.toString(); // 스시: 밥을 뭉쳐놓고 그 위에 재료를 얹어낸 음식

const dict = new Dict();

dict.add(kimchi);
dict.add(tang);
dict.add(sushi);
dict.all()
// kimchi: 한국의 음식,고춧가루로 배추를 버무려 숙성 및 발효시킨 음식
// 연근 갈비탕: 중국의 음식
// 스시: 밥을 뭉쳐놓고 그 위에 재료를 얹어낸 음식

dict.def("kimchi");
// (2) ['한국의 음식', '고춧가루로 배추를 버무려 숙성 및 발효시킨 음식']

dict.size()
// 3

dict.update("kimchi", "김치")

dict.all()
// 연근 갈비탕: 중국의 음식
// 스시: 밥을 뭉쳐놓고 그 위에 재료를 얹어낸 음식
// 김치: 한국의 음식,고춧가루로 배추를 버무려 숙성 및 발효시킨 음식

dict.rmv("연근 갈비탕");

dict.all()
// 스시: 밥을 뭉쳐놓고 그 위에 재료를 얹어낸 음식
// 김치: 한국의 음식,고춧가루로 배추를 버무려 숙성 및 발효시킨 음식
```

