# 타입 시스템

## Type Checker와 소통하는 방법

```ts
let a = "hello"
let b: boolean = false;
let c: number[] = []
```

a는 string이라고 추론할 수 있도록 하는 방법

b는 boolean이라고 명시적으로 알려주는 방법

c는 숫자만 들어갈 수 있는 array라고 명시적으로 선언



```ts
const player: object = {
    name: "nico",
};

player.name;
```

객체의 경우도 object라고 명시적으로 선언할 수 있지만 이 때는 오류가 발생



```ts
const player: {
    name: string
} = {
    name: "nico"
};

player.name;
```

객체의 경우도 객체 안의 데이터가 어떤 타입인지 알려줌



가능하면 타입스크립트가 추론하게 하는 것이 좋음

코드가 간결해져 가독성이 올라가기 때문

하지만 명시적으로 선언해주어야 할 경우가 있는데 이는 array 안의 값이 없을 경우 타입을 지정해야 할 때



## optional type

name은 항상 가지고 있고 age는 있거나 없을 경우

```ts
const player: {
    name: string,
    age?: number
} = {
    name: "nico"
};
```

있거나 없는 경우는 `?`를 붙여서 타입 명시



이런 요소를 사용하려면 없을 수도 있기 때문에 에러가 발생함

```ts
const player: {
    name: string,
    age?: number
} = {
    name: "nico"
};

if (player.age && player.age < 10) {
    // ...
};
```

요소가 존재하는지를 먼저 체크 후 사용



## Alias(별칭) 타입 사용

```ts
const playerNico: {
    name: string,
    age?: number
} = {
    name: "nico"
}

const playerLynn: {
    name: string,
    age?: number
} = {
    name: "lynn",
    age: 12
}
```

위와 같이 많은 player를 만들 경우 같은 코드가 반복됨



```ts
type Player = {
    name: string,
    age?: number
};

const nico: Player = {
    name: "nico"
};

const lynn: Player = {
    name: "lynn",
    age: 12
};
```

별칭 타입을 통해 코드를 재사용할 수 있도록 하고 간결하게 해줌



```ts
type Age = number;
type Player = {
    name: string,
    age?: Age
};
```

Age와 같이 객체가 아닌 타입도 별칭으로 사용 가능하지만 굳이 할 필요는 없음

코드가 간결해질 때까지만 별칭을 사용하는 것이 바람직함



## 함수의 return 타입 지정

```ts
type Player = {
    name: string,
    age?: number
};

function playerMaker(name: string) {
    return {
        name: name
        // name
    }
}

const nico = playerMaker("nico");
nico.age = 12; // 에러 발생, age 요소가 없기 때문
```

playerMaker는 string 타입의 name 요소만을 갖는 object를 반환하기 때문



```ts
type Player = {
    name: string,
    age?: number
};

function playerMaker(name: string): Player {
    return {
        name: name
        // name
    }
}

const nico = playerMaker("nico");
nico.age = 12;
```

함수의 괄호 뒤에 타입을 명시해주면 return 타입을 지정할 수 있음



### 화살표 함수 사용

```ts
const PlayerMaker = (name: string): Player => ({ name });
```



## readonly(읽기 전용) 속성

```ts
type Player = {
    readonly name: string,
    age?: number
};

const PlayerMaker = (name: string): Player => ({ name });

const nico = playerMaker("nico");
nico.age = 12;
nico.name = "las"; // 에러 발생
```

읽기 전용 요소기 때문에 바꿀 수 없음



```ts
const numbers: readonly number[] = [1, 2, 3, 4];
numbers.push(1); // 에러 발생
```

readonly number[] 타입에 push라는 것이 존재하지 않기 때문



```ts
const names: readonly string[] = ["1", "2"];
```

불변성을 가지게 되지만 map이나 filter는 가능함



## Tuple

> Array를 생성할 수 있게 해주는데 최소한의 길이를 가져야 하고 특정 위치에 특정 타입이 있어야 함



```ts
const player: [string, number, boolean] = []; // 에러 발생

const player: [string, number, boolean] = ["nico", 1, false];
```

3개의 요소가 필요하고 순서대로 타입을 가져야 한다고 선언했을 경우 사용

빈 배열로 선언한 경우 에러 발생



## 다른 타입

```ts
let a: undefined = undefined;
let b: null = null;

type Player = {
    age?: number // (property) age?: number | undefined
};
```

undefined나 null은 그대로 명시해 사용



```ts
let a = []; // let a: any[]
```

any는 타입스크립트의 보호장치로부터 빠져나오고 싶을 때 사용하는 타입

사용하지 않는 것이 좋고 신중하게 사용해야 함



```ts
const a: any[] = [1, 2, 3];
const b: any = true;

a + b;
```

원래의 타입스크립트라면 에러가 발생해야 하지만 any 타입을 사용해 에러가 발생하지 않음



## unknown

만약 API를 요청했을 때 응답의 타입을 모른다면 unknown을 사용할 수 있음

```ts
let a: unknown;

let b = a + 1; // 에러 발생, a의 타입을 모르기 때문

if (typeof a === "number") {
    let b = a + 1;
}

if (typeof a === "string") {
    let b = a.toUpperCase();
}
```

unknown 변수를 사용하기 위해서는 타입을 알아야 함

타입스크립트가 강제로 타입을 확인시켜 에러를 방지



## void

아무 것도 return 하지 않는 함수에 사용

```ts
function hello() {
    console.log("x");
}; // function hello(): void
```

void의 경우 따로 지정해줄 필요는 없음



## never

함수가 절대 return 하지 않을 때 사용

예를 들어 함수에서 exception(예외)이 발생할 때

```ts
function hello(): never {
    return "X"; // 에러 발생
    
    throw new Error("xxx"); // 정상 작동, return 하지 않고 오류를 발생시키는 함수로 만듦
}
```



```ts
function hello(name: string|number) {
    if (typeof name === "string") {
        name // name: string
    } else if (typeof name === "number") {
        name // name: number
    } else {
        name // name: never
    }
}
```

name이 string이거나 number일 수 있고

타입을 확인해서 조건 분기를 하지만 else는 절대 도달할 수 없기 때문에 never 타입이 붙음